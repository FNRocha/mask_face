# -*- coding: utf-8 -*-
"""tracker.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TsRaqZJW6k-2OaydYWkXCnSrgFfnIjuM
"""

import cv2
from google.colab.patches import cv2_imshow
import sys

import numpy as np
import cv2
import time
import math

cv2.__version__

tracker_type = "KCF"

tracker = cv2.TrackerKCF_create()

cap = cv2.VideoCapture("simone_stunt.mp4")
num_frame = int(cap.get(cv2.CAP_PROP_FRAME_COUNT ))
frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = int(cap.get(cv2.CAP_PROP_FPS))

fourcc = cv2.VideoWriter_fourcc(*'XVID')
writer = cv2.VideoWriter("tracker_KCF.avi", fourcc, 60,(frame_width, frame_height), True)

# Read first frame.
while True:
  ok, frame = cap.read()
  
  if not ok:
    print("End")   
    break; 
  #cv2.imwrite("frame_" + str(i) + ".jpg",frame)
  
  writer.write(frame)

writer.release()
cap.release()

cap.release()

cv2.imwrite("frame1.jpg",frame)

# Commented out IPython magic to ensure Python compatibility.
# % rm frame*

# Define an initial bounding box

bbox = (287, 23, 86, 320)

# Uncomment the line below to select a different bounding box
#bbox = cv2.selectROI(frame, False)

# Initialize tracker with first frame and bounding box
ok = tracker.init(frame, bbox)

fps = 15

# vidwriter
fourcc = cv2.VideoWriter_fourcc('M','J','P','G')

writer = None

i=1
while True:
  # Read a new frame
  ok, frame = video.read()

  if width is None or height is None:
    
    height, width = frame.shape[:2]

  #if writer is None:
    # vidwriter
    #fourcc = cv2.VideoWriter_fourcc('M','J','P','G')
    #writer = cv2.VideoWriter("tracker_KCF" + ".mp4", fourcc, 30,(frame.shape[1], frame.shape[0]), True)

  if not ok:
    print("fim")
    vw.release()
    video.release()
    break
  
  cv2.imwrite("frame" + str(i) + ".jpg",frame)

  # Display result
  #writer.write(frame)

i

timer = cv2.getTickCount()

  # Update tracker
  ok, bbox = tracker.update(frame)

  # Draw bounding box

  if ok:
  # Tracking success
    p1 = (int(bbox[0]), int(bbox[1]))

    p2 = (int(bbox[0] + bbox[2]), int(bbox[1] + bbox[3]))

    cv2.rectangle(frame, p1, p2, (255,0,0), 2, 1)

  else :

    # Tracking failure
    cv2.putText(frame, "Tracking failure detected", (100,80), cv2.FONT_HERSHEY_SIMPLEX, 0.75,(0,0,255),2)


  # Display tracker type on frame
  cv2.putText(frame, tracker_type + " Tracker", (100,20), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (50,170,50),2);

  # Display FPS on frame
  cv2.putText(frame, "FPS : " + str(int(fps)), (100,50), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (50,170,50), 2);





def draw(flow):
    M = 10
    (h, w) = flow.shape[:2]
    mag, ang = cv2.cartToPolar(flow[...,0], flow[...,1])
    hsv = np.zeros((h, w, 3), np.uint8) # Cria uma imagem HSV preta na dimensão do frame - flow
    hsv[..., 0] = ang * (180 / np.pi / 2)  # Parte da Conversão do ângulo em cor
    hsv[..., 1] = 0xFF
    hsv[..., 2] = cv2.normalize(mag,None,0,255,cv2.NORM_MINMAX)  # Parte da Conversão do ângulo em cor


    flow_img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)  # Converte a imagem hsv em BGR


    return flow_img

grava = True
video_in = "/content/cars_low.mp4"
video_out = "/content/cars_low_out.mp4"
cam = cv2.VideoCapture(video_in)

if __name__ == '__main__':

    Threshold = 5
    scala = .4
    # Leitura de primeiro frame 
    ret, prev = cam.read() 
    prev = cv2.resize(prev, None, fx=scala, fy=scala)

    # codecs para gravar vídeo
    fourcc = cv2.VideoWriter_fourcc(*'XVID') 

    # instancia de escrita de video.
    out = cv2.VideoWriter(video_out, fourcc, 20.0, (prev.shape[1] * 2, prev.shape[0]))

    # Converte frame em escala de cinza
    prevgray = cv2.cvtColor(prev, cv2.COLOR_BGR2GRAY)  
    
    while True:
        ret, img = cam.read()
        
        if not ret:
          break;

        img = cv2.resize(img, None, fx=scala, fy=scala)

        # Converte frame em escala de cinza
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        flow = cv2.calcOpticalFlowFarneback(prevgray,gray,None,0.5,30,Threshold,1,1,1.02,cv2.OPTFLOW_FARNEBACK_GAUSSIAN)

        prevgray = gray

        flow_img = draw(flow)
         
        #concatena imagens
        final = cv2.hconcat([img,flow_img])
        if grava == True:
            out.write(final)


        #final = cv2.resize(final, None, fx=1*(1/scala), fy=1*(1/scala))
        #cv2.imshow('Final', final)        
  
out.release()

out.release()

video = cv2.VideoCapture("videos/chaplin.mp4")